"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayAsCollection = exports.collectionFactory = exports.validationFactory = exports.generateTypedEntity = exports.singular = exports.pluralize = exports.config = void 0;
const lodash_1 = require("lodash");
const collection_1 = require("./collection");
const runtypes_1 = require("runtypes");
const RDate = (0, runtypes_1.InstanceOf)(Date);
// these are intended to be overridden by individual applications when generating types
exports.config = {
    RId: runtypes_1.String,
    dataSourceFactory: function (entity) {
        throw new Error("peers-kore orm `factory.config.dataSourceFactory` function needs to be set before types can be generated and imported");
    },
    entities: {},
    defaultPrimaryKey: { name: "id", dataType: "string" },
};
const fileHeader = `
// Warning: this file is generated by "peers-kore/orm/factory.ts"

import { factory } from 'peers-kore';`;
function colTypeToTypescriptType(colType) {
    switch (colType) {
        case 'id': return 'string';
        default:
            return colType;
    }
}
async function genIType(entity) {
    let code = "";
    if (entity.extends) {
        code += `import { I${entity.extends.name} } from './${entity.extends.name}';\n\n`;
    }
    else {
        code += `\n`;
    }
    code += `export interface I${entity.name} ${entity.extends ? `extends I${entity.extends.name}` : ''} {`;
    if (!entity.extends) {
        const col = entity.primaryKey || exports.config.defaultPrimaryKey;
        code += `\n  ${col.name}${col.optional ? '?' : ''}: ${colTypeToTypescriptType(col.dataType)}`;
    }
    for (const col of entity.fields) {
        code += `\n  ${col.name}${col.optional ? '?' : ''}: ${colTypeToTypescriptType(col.dataType)}`;
    }
    code += `\n}`;
    return code;
}
function pluralize(name) {
    // if (name.endsWith('entry')) {
    //   return name.substring(0, name.length-2) + 'ies'
    // }
    if (name.endsWith('s')) {
        return name + 'es';
    }
    return name + 's';
}
exports.pluralize = pluralize;
function singular(name) {
    if (name.endsWith('es')) {
        return name.substring(0, name.length - 1);
    }
    if (name.endsWith('s')) {
        return name.substring(0, name.length);
    }
    return name;
}
exports.singular = singular;
async function genCollection(entity) {
    const namePlural = entity.namePlural || pluralize(entity.name);
    return `export const ${namePlural} = factory.collectionFactory<I${entity.name}>(factory.config.entities.${entity.name})\n`;
}
async function generateTypedEntity(entity, options) {
    var _a, _b, _c;
    let code = fileHeader;
    if (options === null || options === void 0 ? void 0 : options.fileHeader) {
        code += `\n` + options.fileHeader;
    }
    // code += `\n\n// ${entity.name}`
    if (!(options === null || options === void 0 ? void 0 : options.dontGenInterface)) {
        code += `\n` + await genIType(entity);
    }
    code += `\n` + await genCollection(entity);
    if (options === null || options === void 0 ? void 0 : options.fileFooter) {
        code += `\n` + options.fileFooter;
    }
    if ((options === null || options === void 0 ? void 0 : options.dontWiteFile)) {
        return code;
    }
    const fs = (_a = options === null || options === void 0 ? void 0 : options.fs) !== null && _a !== void 0 ? _a : eval("require(`fs`)");
    let filePath = (_b = options === null || options === void 0 ? void 0 : options.fileDir) !== null && _b !== void 0 ? _b : `./orm-types`;
    if (!fs.existsSync(filePath)) {
        fs.mkdirSync(filePath, { recursive: true });
    }
    filePath += '/' + ((_c = options === null || options === void 0 ? void 0 : options.fileName) !== null && _c !== void 0 ? _c : `${entity.name}.ts`);
    fs.writeFileSync(filePath, code);
    return true;
}
exports.generateTypedEntity = generateTypedEntity;
function FieldTypeToRField(fieldType) {
    switch (fieldType) {
        case 'id':
            return exports.config.RId;
        case 'Date':
            return RDate;
        case 'string':
            return runtypes_1.String;
        case 'any':
            return runtypes_1.Unknown;
        case 'boolean':
            return runtypes_1.Boolean;
        case 'number':
            return runtypes_1.Number;
        default:
            throw new Error('Unhandled or unrecognized FieldType: ' + fieldType);
    }
}
function validationFactory(entity) {
    const rFields = {};
    for (const field of entity.fields) {
        let rField = FieldTypeToRField(field.dataType);
        if (field.optional) {
            rField = rField.optional().nullable();
        }
        if (field.array) {
            console.warn(`array types in kore.orm.factory have not been fully implemented`);
        }
        rFields[field.name] = rField;
    }
    const rType = (0, runtypes_1.Record)(rFields);
    function validate(data) {
        const validationResult = rType.validate(data);
        if (!validationResult.success) {
            const details = validationResult === null || validationResult === void 0 ? void 0 : validationResult.details;
            throw new Error('Validation failed: ' + JSON.stringify(details, null, 2));
        }
    }
    return validate;
}
exports.validationFactory = validationFactory;
function collectionFactory(entity, dataSource = exports.config.dataSourceFactory(entity), validate = validationFactory(entity)) {
    // hidden feature of converting fkTypeName to fkType
    for (const field of entity.fields) {
        if (typeof field.fkType === "string") {
            const eName = String(field.fkType);
            field.fkType = Object.values(exports.config.entities).find(e => e.name === eName || e.namePlural === eName);
        }
    }
    // instantiate any fkCollections that don't exist
    for (const field of entity.fields) {
        if (field.fkType && !field.fkCollection) {
            field.fkCollection = collectionFactory(field.fkType);
        }
    }
    return new collection_1.Collection(entity, validate, dataSource);
}
exports.collectionFactory = collectionFactory;
let arrayCollectionCount = 0;
function arrayAsCollection(ary, entityOpts = {}) {
    let fields = entityOpts === null || entityOpts === void 0 ? void 0 : entityOpts.fields;
    delete entityOpts.fields;
    if (!fields) {
        const fieldNames = (0, lodash_1.uniq)(ary.map(item => Object.keys(item)).flat());
        fields = fieldNames.map(name => {
            var _a;
            const firstValue = (_a = ary.find(item => item[name] !== undefined && item[name] !== null)) === null || _a === void 0 ? void 0 : _a[name];
            const valueType = typeof firstValue;
            let dataType = 'any';
            if (valueType !== 'object' && valueType !== 'function' && valueType !== 'symbol') {
                dataType = valueType;
            }
            let optional = false;
            return {
                name,
                dataType,
                optional
            };
        });
    }
    const entity = Object.assign({ name: `ArrayCollection_${arrayCollectionCount++}`, fields }, entityOpts);
    const primaryKey = entity.primaryKey || exports.config.defaultPrimaryKey;
    const dataSource = {
        get(id) {
            return Promise.resolve(ary.find(item => item[primaryKey.name] === id));
        },
        list(lastModified, group, direction) {
            const iValue = 0;
            const cursor = {
                value: null,
                next() {
                    if (iValue >= ary.length) {
                        return Promise.resolve(null);
                    }
                    cursor.value = ary[iValue];
                    return Promise.resolve(cursor.value);
                },
            };
            return Promise.resolve(cursor);
        },
        query(query) {
            // TODO
            return Promise.resolve(ary);
        },
        async remove(data) {
            const arrayEntry = await dataSource.get(data[primaryKey.name]);
            if (arrayEntry) {
                ary.splice(ary.indexOf(arrayEntry), 1);
            }
            return Promise.resolve(true);
        },
        save(data) {
            const arrayEntry = dataSource.get(data[primaryKey.name]);
            if (arrayEntry) {
                Object.assign(arrayEntry, data);
            }
            else {
                ary.push(data);
            }
            return Promise.resolve(arrayEntry);
        },
    };
    return collectionFactory(entity, dataSource);
}
exports.arrayAsCollection = arrayAsCollection;
//# sourceMappingURL=factory.js.map