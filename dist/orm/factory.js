"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectionFactory = exports.validationFactory = exports.generateTypedEntity = exports.singular = exports.pluralize = exports.config = void 0;
const collection_1 = require("./collection");
const runtypes_1 = require("runtypes");
const RDate = (0, runtypes_1.InstanceOf)(Date);
// these are intended to be overridden by individual applications when generating types
exports.config = {
    RId: runtypes_1.String,
    dataSourceFactory: function (entity) {
        throw new Error("peers-kore orm `factory.config.dataSourceFactory` function needs to be set before types can be generated and imported");
    },
    entities: {},
    defaultPrimaryKey: { name: "id", dataType: "string" },
};
const fileHeader = `
// Warning: this file is generated by "peers-kore/orm/factory.ts"

import { factory } from 'peers-kore';`;
function colTypeToTypescriptType(colType) {
    switch (colType) {
        case 'id': return 'string';
        default:
            return colType;
    }
}
async function genIType(entity) {
    let code = "";
    if (entity.extends) {
        code += `import { I${entity.extends.name} } from './${entity.extends.name}';\n\n`;
    }
    else {
        code += `\n`;
    }
    code += `export interface I${entity.name} ${entity.extends ? `extends I${entity.extends.name}` : ''} {`;
    if (!entity.extends) {
        const col = entity.primaryKey || exports.config.defaultPrimaryKey;
        code += `\n  ${col.name}${col.optional ? '?' : ''}: ${colTypeToTypescriptType(col.dataType)}`;
    }
    for (const col of entity.fields) {
        code += `\n  ${col.name}${col.optional ? '?' : ''}: ${colTypeToTypescriptType(col.dataType)}`;
    }
    code += `\n}`;
    return code;
}
function pluralize(name) {
    if (name.endsWith('s')) {
        return name + 'es';
    }
    return name + 's';
}
exports.pluralize = pluralize;
function singular(name) {
    if (name.endsWith('es')) {
        return name.substring(0, name.length - 1);
    }
    if (name.endsWith('s')) {
        return name.substring(0, name.length);
    }
    return name;
}
exports.singular = singular;
async function genCollection(entity) {
    const namePlural = entity.namePlural || pluralize(entity.name);
    return `export const ${namePlural} = factory.collectionFactory<I${entity.name}>(factory.config.entities.${entity.name})\n`;
}
async function generateTypedEntity(entity, options) {
    var _a, _b, _c;
    let code = fileHeader;
    if (options === null || options === void 0 ? void 0 : options.fileHeader) {
        code += `\n` + options.fileHeader;
    }
    // code += `\n\n// ${entity.name}`
    if (!(options === null || options === void 0 ? void 0 : options.dontGenInterface)) {
        code += `\n` + await genIType(entity);
    }
    code += `\n` + await genCollection(entity);
    if (options === null || options === void 0 ? void 0 : options.fileFooter) {
        code += `\n` + options.fileFooter;
    }
    if ((options === null || options === void 0 ? void 0 : options.dontWiteFile)) {
        return code;
    }
    const fs = (_a = options === null || options === void 0 ? void 0 : options.fs) !== null && _a !== void 0 ? _a : eval("require(`fs`)");
    let filePath = (_b = options === null || options === void 0 ? void 0 : options.fileDir) !== null && _b !== void 0 ? _b : `./orm-types`;
    if (!fs.existsSync(filePath)) {
        fs.mkdirSync(filePath, { recursive: true });
    }
    filePath += '/' + ((_c = options === null || options === void 0 ? void 0 : options.fileName) !== null && _c !== void 0 ? _c : `${entity.name}.ts`);
    fs.writeFileSync(filePath, code);
    return true;
}
exports.generateTypedEntity = generateTypedEntity;
function FieldTypeToRField(fieldType) {
    switch (fieldType) {
        case 'id':
            return exports.config.RId;
        case 'Date':
            return RDate;
        case 'string':
            return runtypes_1.String;
        case 'any':
            return runtypes_1.Unknown;
        case 'boolean':
            return runtypes_1.Boolean;
        case 'number':
            return runtypes_1.Number;
        default:
            throw new Error('Unhandled or unrecognized FieldType: ' + fieldType);
    }
}
function validationFactory(entity) {
    const rFields = {};
    for (const field of entity.fields) {
        let rField = FieldTypeToRField(field.dataType);
        if (field.optional) {
            rField = rField.optional().nullable();
        }
        if (field.array) {
            console.warn(`array types in kore.orm.factory have not been fully implemented`);
        }
        rFields[field.name] = rField;
    }
    const rType = (0, runtypes_1.Record)(rFields);
    function validate(data) {
        const validationResult = rType.validate(data);
        if (!validationResult.success) {
            const details = validationResult === null || validationResult === void 0 ? void 0 : validationResult.details;
            throw new Error('Validation failed: ' + JSON.stringify(details, null, 2));
        }
    }
    return validate;
}
exports.validationFactory = validationFactory;
function collectionFactory(entity, dataSource = exports.config.dataSourceFactory(entity), validate = validationFactory(entity)) {
    return new collection_1.Collection(entity, validate, dataSource);
}
exports.collectionFactory = collectionFactory;
//# sourceMappingURL=factory.js.map