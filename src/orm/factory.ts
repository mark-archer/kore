import { Collection, FieldType, IDataSource, IField } from "./collection"

import {
  Boolean as RBoolean,
  Number as RNumber,
  String as RString,
  Record as RObject,
  InstanceOf as RInstanceOf,
  Unknown as RAny
} from 'runtypes';

const RDate = RInstanceOf(Date);

export interface IEntity {
  id?: string
  name: string
  namePlural?: string
  fields: IField[]
  primaryKey?: IField
  extends?: IEntity
  displayValue?: string | ((doc: any) => string)
}

// these are intended to be overridden by individual applications when generating types
export const dynamic = {
  RId: RString,
  dataSourceFactory: (entity: IEntity) => {
    throw new Error("The `orm.factory.dataSourceFactory` function needs to be set before types can be generated and imported");
  },
  entities: {} as Record<string, IEntity>
}

const fileHeader = `
// Warning: this file is generated by "peers-kore/orm/factory.ts"

import { collectionFactory, dynamic } from 'peers-kore/orm/factory';

`;

function colTypeToTypescriptType(colType: FieldType) {
  switch (colType) {
    case 'id': return 'string';
    default:
      return colType
  }
}

async function genIType(TType: IEntity) {
  let code = `export interface I${TType.name} ${TType.extends ? `extends I${TType.extends.name}` : ''} {`;
  for (const col of TType.fields) {
    code += `\n  ${col.name}${col.optional ? '?' : ''}: ${colTypeToTypescriptType(col.dataType)}`
  }
  code += `\n}`
  return code;
}

export function pluralize(name: string) {
  if (name.endsWith('s')) {
    return name + 'es';
  }
  return name + 's';
}

async function genCollection(entity: IEntity) {
  const namePlural = entity.namePlural || pluralize(entity.name);
  return `export const ${namePlural} = collectionFactory<I${entity.name}>(dynamic.entities.${entity.name})\n`;
}

export async function generateTypedEntity(
  entity: IEntity,
  options?: {
    dontGenInterface?: boolean,
    dontWiteFile?: boolean,
    fileDir?: string,
    fileName?: string,
    fileHeader?: string,
    fileFooter?: string,
  }
) {
  let code = fileHeader;
  if (options?.fileHeader) {
    code += `\n` + options.fileHeader;
  }

  code += `\n\n// ${entity.name}`
  if (!(options?.dontGenInterface)) {
    code += `\n` + await genIType(entity);
  }
  code += `\n` + await genCollection(entity);

  if (options?.fileFooter) {
    code += `\n` + options.fileFooter;
  }

  if ((options?.dontWiteFile)) {
    return code;
  }

  const fs = require('fs');
  let filePath = options?.fileDir ?? `./orm-types`;
  if (!fs.existsSync(filePath)) {
    fs.mkdirSync(filePath, { recursive: true });
  }
  filePath += '/' + (options?.fileName ?? `${entity.name}.ts`);
  fs.writeFileSync(filePath, code);
  return true;
}

function FieldTypeToRField(fieldType: FieldType) {
  switch (fieldType) {
    case 'id':
      return dynamic.RId;
    case 'Date':
      return RDate;
    case 'string':
      return RString;
    case 'any':
      return RAny;
    case 'boolean':
      return RBoolean;
    case 'number':
      return RNumber;
    default:
      throw new Error('Unhandled or unrecognized FieldType: ' + fieldType);
  }
}

export function validationFactory(entity: IEntity) {
  const rFields = {};
  for (const field of entity.fields) {
    let rField: any = FieldTypeToRField(field.dataType);
    if (field.optional) {
      rField = rField.optional().nullable();
    }
    if (field.array) {
      console.warn(`array types in kore.orm.factory have not been fully implemented`);
    }
    rFields[field.name] = rField;
  }
  const rType = RObject(rFields);
  function validate(data) {
    const validationResult = rType.validate(data)
    if (!validationResult.success) {
      const details = (validationResult as any)?.details;
      throw new Error('Validation failed: ' + JSON.stringify(details, null, 2))
    }
  }
  return validate;
}

export function collectionFactory<T>(
  entity: IEntity, 
  dataSource: IDataSource<T> = dynamic.dataSourceFactory(entity)
): Collection<T> {
  const validate = validationFactory(entity);
  return new Collection<T>(entity, validate, dataSource);
}
